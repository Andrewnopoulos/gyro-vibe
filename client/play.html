<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Gyro-Vibe - Play Now</title>
  <script type="importmap">
    {
      "imports": {
        "three": "/node_modules/three/build/three.module.js",
        "three/addons/": "/node_modules/three/examples/jsm/"
      }
    }
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #121212;
      color: white;
      overflow: hidden;
    }
    .container {
      max-width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .header {
      padding: 15px;
      background-color: #1a1a1a;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      text-align: center;
    }
    h1 {
      margin: 0;
      font-size: 1.5rem;
      color: #17a2b8;
    }
    .game-area {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    .info-text {
      margin: 20px;
      text-align: center;
      color: #cccccc;
      font-size: 0.9rem;
      max-width: 300px;
    }
    .canvas-container {
      width: 100%;
      flex-grow: 1;
      display: none; /* Initially hidden */
      position: relative;
    }
    #gameCanvas {
      width: 100%;
      height: 100%;
      background-color: #000;
    }
    .game-controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 15px;
    }
    .control-button {
      background-color: rgba(23, 162, 184, 0.7);
      color: white;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .back-button {
      position: absolute;
      top: 15px;
      left: 15px;
      background-color: rgba(0,0,0,0.5);
      color: white;
      border: none;
      border-radius: 5px;
      padding: 8px 15px;
      font-size: 0.9rem;
    }
    
    /* Room info panel */
    .room-info-panel {
      position: absolute;
      top: 15px;
      right: 15px;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      border-radius: 5px;
      padding: 8px 12px;
      font-size: 0.8rem;
      max-width: 180px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      z-index: 10;
      transition: all 0.3s ease;
    }
    
    .room-info-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 3px;
    }
    
    .room-code {
      font-family: monospace;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: bold;
      color: #4fc3f7;
    }
    
    .player-count {
      color: #4fc3f7;
      font-weight: bold;
    }
    
    .collapse-btn {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
      cursor: pointer;
      padding: 0 3px;
    }
    
    .player-list {
      max-height: 100px;
      overflow-y: auto;
      margin-top: 5px;
      font-size: 0.75rem;
    }
    
    .player-item {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
      padding: 2px 0;
    }
    
    .player-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 5px;
      display: inline-block;
    }
    
    .player-icon.mobile {
      background-color: #ff7043;
    }
    
    .player-icon.desktop {
      background-color: #66bb6a;
    }
    
    .player-icon.me {
      border: 2px solid white;
      box-sizing: content-box;
      margin-right: 3px;
    }
    
    .player-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 110px;
    }
    
    .player-name.me {
      font-weight: bold;
    }
    
    .connection-indicator {
      position: absolute;
      top: 15px;
      right: 205px;
      background-color: rgba(0, 0, 0, 0.6);
      border-radius: 5px;
      padding: 5px 8px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 5px;
      opacity: 0.8;
      transition: opacity 0.3s ease;
    }
    
    .connection-indicator:hover {
      opacity: 1;
    }
    
    .signal-bar {
      width: 4px;
      height: 6px;
      background-color: rgba(255, 255, 255, 0.3);
      margin-right: 1px;
      border-radius: 1px;
      transition: background-color 0.5s ease;
    }
    
    .signal-bar.active {
      background-color: #4caf50;
    }
    
    .signal-bar.poor {
      background-color: #ff9800;
    }
    
    .signal-bar.bad {
      background-color: #f44336;
    }
    
    .connection-text {
      color: white;
      font-size: 0.65rem;
    }
    
    /* Notification styles */
    .notification-container {
      position: absolute;
      bottom: 90px;
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
      z-index: 100;
    }
    
    .notification {
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      margin-bottom: 5px;
      font-size: 0.8rem;
      max-width: 80%;
      text-align: center;
      opacity: 0;
      transform: translateY(20px);
      animation: notification-appear 0.3s forwards, notification-disappear 0.3s 4s forwards;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes notification-appear {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes notification-disappear {
      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }
    
    .notification.join {
      border-left: 3px solid #4caf50;
    }
    
    .notification.leave {
      border-left: 3px solid #f44336;
    }
    
    .notification.info {
      border-left: 3px solid #2196f3;
    }
    
    .notification.warning {
      border-left: 3px solid #ff9800;
    }
    
    /* Collapsed room info panel */
    .room-info-panel.collapsed {
      width: 30px;
      height: 30px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      overflow: hidden;
    }
    
    .room-info-panel.collapsed .room-info-header,
    .room-info-panel.collapsed .player-list {
      display: none;
    }
    
    .expand-btn {
      font-size: 1.2rem;
      color: #4fc3f7;
    }
    
    /* Multiplayer Lobby Styles */
    .lobby-container {
      width: 90%;
      max-width: 500px;
      background-color: rgba(0, 0, 0, 0.9);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      color: white;
    }
    .lobby-title {
      margin: 0 0 20px 0;
      font-size: 24px;
      color: #4fc3f7;
      text-align: center;
    }
    .username-section {
      margin-bottom: 20px;
      text-align: left;
    }
    .username-label {
      display: block;
      margin-bottom: 5px;
    }
    .username-input {
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #555;
      border-radius: 4px;
      background-color: rgba(30, 30, 30, 0.9);
      color: white;
      margin-bottom: 10px;
    }
    .join-section {
      margin-bottom: 20px;
      text-align: left;
    }
    .join-by-code {
      margin-bottom: 20px;
      padding: 15px;
      background-color: rgba(80, 50, 100, 0.4);
      border-radius: 8px;
    }
    .section-title {
      margin: 0 0 10px 0;
      font-size: 18px;
    }
    .code-input-container {
      display: flex;
      gap: 10px;
    }
    .room-code-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #555;
      border-radius: 4px;
      background-color: rgba(30, 30, 30, 0.9);
      color: white;
    }
    .join-button {
      padding: 8px 15px;
      background-color: #17a2b8;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .available-rooms {
      padding: 15px;
      background-color: rgba(50, 80, 50, 0.4);
      border-radius: 8px;
    }
    .refresh-button {
      padding: 5px 10px;
      background-color: #444;
      color: white;
      border: none;
      border-radius: 4px;
      margin-bottom: 10px;
      cursor: pointer;
    }
    .rooms-list {
      max-height: 200px;
      overflow-y: auto;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 5px;
      margin-top: 5px;
    }
    .no-rooms-message {
      padding: 10px;
      text-align: center;
      color: #888;
      font-style: italic;
    }
    .room-item {
      padding: 10px;
      margin-bottom: 5px;
      background-color: rgba(50, 50, 80, 0.4);
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .room-item:hover {
      background-color: rgba(70, 70, 120, 0.6);
    }
    .room-name {
      font-weight: bold;
    }
    .room-info {
      font-size: 12px;
      margin-top: 3px;
    }
    .room-code {
      float: right;
      font-family: monospace;
      color: #aaf;
    }
    .status-message {
      margin-top: 10px;
      color: #ff5555;
      min-height: 20px;
      display: none;
    }
    
    .connection-status {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      text-align: center;
      z-index: 100;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      margin: 0 auto 10px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #17a2b8;
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Gyro-Vibe Multiplayer</h1>
    </div>
    
    <div class="game-area" id="lobbyScreen">
      <div class="lobby-container">
        <h1 class="lobby-title">Join a Game</h1>
        
        <!-- Username input section -->
        <div class="username-section">
          <label class="username-label">Your Username:</label>
          <input id="username-input" type="text" placeholder="Enter your username" class="username-input">
        </div>
        
        <div class="join-section">
          <!-- Join by code section -->
          <div class="join-by-code">
            <h2 class="section-title">Join with Room Code</h2>
            <label>Room Code:</label>
            <div class="code-input-container">
              <input id="room-code-input" type="text" placeholder="Enter room code" class="room-code-input">
              <button id="join-room-btn" class="join-button">Join</button>
            </div>
          </div>
          
          <!-- Available rooms section -->
          <div class="available-rooms">
            <h2 class="section-title">Available Rooms</h2>
            <button id="refresh-rooms-btn" class="refresh-button">Refresh List</button>
            <div id="rooms-list" class="rooms-list">
              <div id="no-rooms-message" class="no-rooms-message">No rooms available. Refresh the list.</div>
            </div>
          </div>
        </div>
        
        <!-- Status message area -->
        <div id="lobby-status-message" class="status-message"></div>
        
        <!-- Connection status spinner -->
        <div id="connection-status" class="connection-status" style="display: none;">
          <div class="spinner"></div>
          <div id="connection-status-text">Connecting...</div>
        </div>
      </div>
    </div>
    
    <div class="canvas-container" id="gameScreen">
      <canvas id="gameCanvas"></canvas>
      <button id="backBtn" class="back-button">Back</button>
      
      <!-- Room info panel -->
      <div id="roomInfoPanel" class="room-info-panel">
        <div class="room-info-header">
          <span class="room-code" id="currentRoomCode">----</span>
          <span class="player-count"><span id="playerCount">0</span>/<span id="maxPlayers">8</span></span>
          <button class="collapse-btn" id="collapseRoomInfo">−</button>
        </div>
        <div class="player-list" id="playerList">
          <!-- Player items will be added dynamically -->
        </div>
      </div>
      
      <!-- Connection status indicator -->
      <div id="connectionIndicator" class="connection-indicator">
        <div class="signal-bars">
          <div class="signal-bar" id="signalBar1"></div>
          <div class="signal-bar" id="signalBar2"></div>
          <div class="signal-bar" id="signalBar3"></div>
          <div class="signal-bar" id="signalBar4"></div>
        </div>
        <span class="connection-text" id="connectionText">Connecting...</span>
      </div>
      
      <!-- Notification container -->
      <div id="notificationContainer" class="notification-container">
        <!-- Notifications will be added dynamically -->
      </div>
      
      <!-- Game controls removed in simplified gameplay -->
    </div>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    window.SocketIOLib = window.io;
  </script>
  <script type="module">
    import { EventBus } from './js/utils/event-bus.js';
    import { SocketManager } from './js/communication/socket-manager.js';
    import { GameStateManager } from './js/game/game-state-manager.js';
    import { MobileGameManager } from './js/game/mobile/index.js';
    
    // DOM elements
    const lobbyScreen = document.getElementById('lobbyScreen');
    const gameScreen = document.getElementById('gameScreen');
    const gameCanvas = document.getElementById('gameCanvas');
    const usernameInput = document.getElementById('username-input');
    const roomCodeInput = document.getElementById('room-code-input');
    const joinRoomBtn = document.getElementById('join-room-btn');
    const refreshRoomsBtn = document.getElementById('refresh-rooms-btn');
    const roomsList = document.getElementById('rooms-list');
    const noRoomsMessage = document.getElementById('no-rooms-message');
    const lobbyStatusMessage = document.getElementById('lobby-status-message');
    const connectionStatus = document.getElementById('connection-status');
    const connectionStatusText = document.getElementById('connection-status-text');
    const backBtn = document.getElementById('backBtn');
    
    // Game screen UI elements
    const roomInfoPanel = document.getElementById('roomInfoPanel');
    const currentRoomCode = document.getElementById('currentRoomCode');
    const playerCount = document.getElementById('playerCount');
    const maxPlayers = document.getElementById('maxPlayers');
    const playerList = document.getElementById('playerList');
    const collapseRoomInfo = document.getElementById('collapseRoomInfo');
    const connectionIndicator = document.getElementById('connectionIndicator');
    const connectionText = document.getElementById('connectionText');
    const signalBars = [
      document.getElementById('signalBar1'),
      document.getElementById('signalBar2'),
      document.getElementById('signalBar3'),
      document.getElementById('signalBar4')
    ];
    const notificationContainer = document.getElementById('notificationContainer');
    
    // Set up canvas and resize handling
    function resizeCanvas() {
      const container = gameCanvas.parentElement;
      gameCanvas.width = container.clientWidth;
      gameCanvas.height = container.clientHeight;
    }
    
    window.addEventListener('resize', resizeCanvas);
    
    // Mobile device sensor data
    const sensorData = {
      orientation: {
        alpha: 0,
        beta: 0,
        gamma: 0
      },
      acceleration: {
        x: 0,
        y: 0,
        z: 0
      },
      active: false
    };
    
    // Room info panel setup
    collapseRoomInfo.addEventListener('click', () => {
      roomInfoPanel.classList.toggle('collapsed');
      collapseRoomInfo.textContent = roomInfoPanel.classList.contains('collapsed') ? '+' : '−';
      
      // If collapsed, add click handler to expand
      if (roomInfoPanel.classList.contains('collapsed')) {
        roomInfoPanel.innerHTML = '<span class="expand-btn">+</span>';
        roomInfoPanel.addEventListener('click', expandPanel);
      } else {
        roomInfoPanel.removeEventListener('click', expandPanel);
      }
    });
    
    function expandPanel() {
      roomInfoPanel.classList.remove('collapsed');
      // Rebuild the panel structure
      roomInfoPanel.innerHTML = `
        <div class="room-info-header">
          <span class="room-code" id="currentRoomCode">${currentRoomCode.textContent || '----'}</span>
          <span class="player-count"><span id="playerCount">${playerCount.textContent || '0'}</span>/<span id="maxPlayers">${maxPlayers.textContent || '8'}</span></span>
          <button class="collapse-btn" id="collapseRoomInfo">−</button>
        </div>
        <div class="player-list" id="playerList"></div>
      `;
      
      // Re-reference DOM elements
      document.getElementById('collapseRoomInfo').addEventListener('click', () => {
        roomInfoPanel.classList.toggle('collapsed');
        document.getElementById('collapseRoomInfo').textContent = roomInfoPanel.classList.contains('collapsed') ? '+' : '−';
        
        if (roomInfoPanel.classList.contains('collapsed')) {
          roomInfoPanel.innerHTML = '<span class="expand-btn">+</span>';
          roomInfoPanel.addEventListener('click', expandPanel);
        }
      });
      
      // Rebuild player list
      const playerListElement = document.getElementById('playerList');
      if (window.currentPlayers) {
        window.currentPlayers.forEach(player => {
          addPlayerToList(player, playerListElement);
        });
      }
      
      roomInfoPanel.removeEventListener('click', expandPanel);
    }
    
    // Helper function to add a player to the list
    function addPlayerToList(player, listElement = playerList) {
      const playerItem = document.createElement('div');
      playerItem.className = 'player-item';
      playerItem.dataset.playerId = player.id;
      
      const isCurrentPlayer = player.id === window.currentPlayerId;
      const deviceType = player.deviceType || (player.isMobilePlayer ? 'mobile' : 'desktop');
      
      playerItem.innerHTML = `
        <span class="player-icon ${deviceType} ${isCurrentPlayer ? 'me' : ''}"></span>
        <span class="player-name ${isCurrentPlayer ? 'me' : ''}">${player.username}</span>
      `;
      
      listElement.appendChild(playerItem);
    }
    
    // Update player list with the current players
    function updatePlayerList(players) {
      window.currentPlayers = players;
      
      // Clear existing list
      playerList.innerHTML = '';
      
      // Update count
      playerCount.textContent = players.length;
      
      // Add players to list
      players.forEach(player => {
        addPlayerToList(player);
      });
    }
    
    // Show a notification
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      
      notificationContainer.appendChild(notification);
      
      // Remove after animation completes (5 seconds)
      setTimeout(() => {
        if (notification.parentNode === notificationContainer) {
          notificationContainer.removeChild(notification);
        }
      }, 5000);
    }
    
    // Update connection indicator
    function updateConnectionIndicator(status = 'connecting', pingTime = 0) {
      // Reset all bars
      signalBars.forEach(bar => {
        bar.className = 'signal-bar';
      });
      
      switch (status) {
        case 'connected':
          // Determine connection quality based on ping time
          let quality = 'good';
          let activeBars = 4;
          
          if (pingTime > 300) {
            quality = 'poor';
            activeBars = 2;
          } else if (pingTime > 150) {
            quality = 'medium';
            activeBars = 3;
          } else if (pingTime > 500) {
            quality = 'bad';
            activeBars = 1;
          }
          
          // Activate appropriate number of bars
          for (let i = 0; i < activeBars; i++) {
            if (quality === 'poor') {
              signalBars[i].classList.add('active', 'poor');
            } else if (quality === 'bad') {
              signalBars[i].classList.add('active', 'bad');
            } else {
              signalBars[i].classList.add('active');
            }
          }
          
          connectionText.textContent = `${quality.toUpperCase()} (${pingTime}ms)`;
          break;
          
        case 'connecting':
          // Show first bar pulsing
          signalBars[0].classList.add('active');
          connectionText.textContent = 'Connecting...';
          break;
          
        case 'disconnected':
          // Show red bars
          signalBars.forEach(bar => {
            bar.classList.add('bad');
          });
          connectionText.textContent = 'Disconnected';
          break;
          
        case 'reconnecting':
          // Show orange first bar
          signalBars[0].classList.add('active', 'poor');
          connectionText.textContent = 'Reconnecting...';
          break;
      }
    }
    
    class MobileLobbyManager {
      constructor() {
        this.eventBus = new EventBus();
        this.socketManager = new SocketManager(this.eventBus);
        this.gameStateManager = new GameStateManager(this.eventBus, this.socketManager);
        this.mobileGameManager = null;
        this.availableRooms = [];
        
        this.setupEventListeners();
        
        // Mobile clients don't need to create sessions
        // They just need to list rooms
        
        // Request available rooms when initialized
        setTimeout(() => {
          this.refreshRoomsList();
          
          // Set up periodic room list refresh
          this.roomRefreshInterval = setInterval(() => {
            this.refreshRoomsList();
          }, 5000); // Refresh every 5 seconds
        }, 1000);
      }
      
      setupEventListeners() {
        // Socket connection events
        this.eventBus.on('socket:connected', this.handleSocketConnected.bind(this));
        this.eventBus.on('socket:disconnected', this.handleSocketDisconnected.bind(this));
        
        // Multiplayer events
        this.eventBus.on('multiplayer:rooms-list', this.handleRoomsList.bind(this));
        this.eventBus.on('multiplayer:room-joined', this.handleRoomJoined.bind(this));
        this.eventBus.on('multiplayer:room-left', this.handleRoomLeft.bind(this));
        this.eventBus.on('multiplayer:room-error', this.handleRoomError.bind(this));
        this.eventBus.on('multiplayer:player-joined', this.handlePlayerJoined.bind(this));
        this.eventBus.on('multiplayer:player-left', this.handlePlayerLeft.bind(this));
        
        // UI event listeners
        joinRoomBtn.addEventListener('click', () => this.handleJoinRoom());
        refreshRoomsBtn.addEventListener('click', () => this.refreshRoomsList());
        backBtn.addEventListener('click', () => this.handleLeaveRoom());
        
        // Forward sensor events to event bus
        window.addEventListener('deviceorientation', (event) => {
          sensorData.orientation.alpha = event.alpha || 0;
          sensorData.orientation.beta = event.beta || 0;
          sensorData.orientation.gamma = event.gamma || 0;
          sensorData.active = true;
          
          this.eventBus.emit('sensor:gyro-updated', {
            alpha: event.alpha || 0,
            beta: event.beta || 0,
            gamma: event.gamma || 0
          });
        });
        
        window.addEventListener('devicemotion', (event) => {
          if (event.accelerationIncludingGravity) {
            sensorData.acceleration.x = event.accelerationIncludingGravity.x || 0;
            sensorData.acceleration.y = event.accelerationIncludingGravity.y || 0;
            sensorData.acceleration.z = event.accelerationIncludingGravity.z || 0;
          }
        });
      }
      
      handleRoomsList(data) {
        this.availableRooms = data.rooms || [];
        this.updateRoomsList();
      }
      
      updateRoomsList() {
        // Clear existing content
        roomsList.innerHTML = '';
        
        if (this.availableRooms.length === 0) {
          roomsList.appendChild(noRoomsMessage);
          return;
        }
        
        // Add rooms to list
        this.availableRooms.forEach(room => {
          const roomItem = document.createElement('div');
          roomItem.className = 'room-item';
          
          roomItem.innerHTML = `
            <div class="room-name">${room.roomName}</div>
            <div class="room-info">
              <span>Players: ${room.playerCount}/${room.maxPlayers}</span>
              <span class="room-code">Code: ${room.roomCode}</span>
            </div>
          `;
          
          roomItem.onclick = () => {
            const username = usernameInput.value.trim() || 'Player' + Math.floor(Math.random() * 1000);
            usernameInput.value = username;
            this.gameStateManager.joinRoom(room.roomCode, username);
          };
          
          roomsList.appendChild(roomItem);
        });
      }
      
      handleJoinRoom() {
        const username = usernameInput.value.trim();
        const roomCode = roomCodeInput.value.trim();
        
        if (!username) {
          this.showLobbyError('Please enter a username');
          return;
        }
        
        if (!roomCode) {
          this.showLobbyError('Please enter a room code');
          return;
        }
        
        // Show connection status
        this.showConnectionStatus('Joining room...');
        
        // Check socket connection
        if (!this.socketManager.isConnected()) {
          this.showConnectionStatus('Connecting to server...');
          setTimeout(() => {
            if (!this.socketManager.isConnected()) {
              this.hideConnectionStatus();
              this.showLobbyError('Failed to connect to server. Please try again.');
              return;
            }
            this.gameStateManager.joinRoom(roomCode, username);
          }, 1500); // Give time for socket to connect
          return;
        }
        
        this.gameStateManager.joinRoom(roomCode, username);
      }
      
      handleLeaveRoom() {
        this.gameStateManager.leaveRoom();
        
        // Return to menu
        gameScreen.style.display = 'none';
        lobbyScreen.style.display = 'flex';
        
        // Clean up mobile game manager if it exists
        if (this.mobileGameManager) {
          this.mobileGameManager.cleanup();
          this.mobileGameManager = null;
        }
        
        // Resume room list refreshing
        if (!this.roomRefreshInterval) {
          this.roomRefreshInterval = setInterval(() => {
            this.refreshRoomsList();
          }, 5000);
        }
      }
      
      refreshRoomsList() {
        this.gameStateManager.listRooms();
      }
      
      handleRoomJoined(data) {
        // Hide connection status
        this.hideConnectionStatus();
        
        // Store local player id for player list highlighting
        window.currentPlayerId = data.playerId;
        
        // Switch to game screen
        lobbyScreen.style.display = 'none';
        gameScreen.style.display = 'block';
        
        // Resize canvas to fill container
        resizeCanvas();
        
        // Update connection status indicator
        updateConnectionIndicator('connected', 100);
        
        // Start sensor access
        this.enableSensors()
          .then(() => {
            console.log('Sensors enabled successfully');
          })
          .catch(error => {
            console.warn('Sensor access issue:', error);
            // Show a non-blocking warning
            showNotification('Limited sensor access. Some features may not work correctly.', 'warning');
          });
        
        // Stop refreshing room list while in a game
        if (this.roomRefreshInterval) {
          clearInterval(this.roomRefreshInterval);
          this.roomRefreshInterval = null;
        }
        
        // Save room info for potential reconnection
        this.lastRoomCode = data.room.roomCode;
        this.lastUsername = data.playerId ? (data.players.find(p => p.id === data.playerId)?.username || '') : '';
        
        // Initialize mobile game manager if not already created
        if (!this.mobileGameManager) {
          try {
            this.mobileGameManager = new MobileGameManager(
              this.eventBus,
              this.socketManager,
              this.gameStateManager
            );
            console.log('Mobile game manager initialized with room data:', data);
          } catch (error) {
            console.error('Failed to initialize mobile game manager:', error);
            this.showLobbyError('Failed to initialize game view. Please try again.');
            this.gameStateManager.leaveRoom();
            return;
          }
        }
        
        // Update room info panel
        currentRoomCode.textContent = data.room.roomCode || '----';
        playerCount.textContent = data.room.players && data.room.players.length ? data.room.players.length : 0;
        maxPlayers.textContent = data.room.maxPlayers || 8;
        
        // Update player list
        updatePlayerList(data.players);
        
        // Make room info panel and connection indicator visible
        roomInfoPanel.style.display = 'block';
        connectionIndicator.style.display = 'flex';
        
        // Add a game message element if it doesn't exist yet
        if (!document.getElementById('game-message')) {
          const messageElement = document.createElement('div');
          messageElement.id = 'game-message';
          messageElement.style.position = 'absolute';
          messageElement.style.top = '70px';
          messageElement.style.left = '0';
          messageElement.style.width = '100%';
          messageElement.style.textAlign = 'center';
          messageElement.style.color = 'white';
          messageElement.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
          messageElement.style.padding = '8px';
          messageElement.style.zIndex = '100';
          messageElement.style.display = 'none';
          gameScreen.appendChild(messageElement);
        }
        
        // Show welcome notification
        showNotification(`Joined room: ${data.room.name}`, 'info');
        
        // If this is a reconnection, show a specific message
        if (this.isReconnecting) {
          showNotification('Successfully reconnected to the room!', 'info');
          this.isReconnecting = false;
        }
      }
      
      handleRoomLeft() {
        // Return to lobby
        gameScreen.style.display = 'none';
        lobbyScreen.style.display = 'flex';
        
        // Reset room info panel
        currentRoomCode.textContent = '----';
        playerCount.textContent = '0';
        playerList.innerHTML = '';
        
        // Hide room info panel and connection indicator in game view
        // (they'll be shown again when joining a new room)
        roomInfoPanel.style.display = 'none';
        connectionIndicator.style.display = 'none';
        
        // Clean up connection state
        window.currentPlayerId = null;
        window.currentPlayers = null;
        
        // Show notification
        showNotification('You left the room', 'info');
      }
      
      handleRoomError(data) {
        this.showLobbyError(data.error);
      }
      
      showLobbyError(message) {
        this.hideConnectionStatus();
        lobbyStatusMessage.textContent = message;
        lobbyStatusMessage.style.display = 'block';
        
        // Hide after 5 seconds
        setTimeout(() => {
          lobbyStatusMessage.style.display = 'none';
        }, 5000);
      }
      
      showConnectionStatus(message) {
        connectionStatusText.textContent = message || 'Connecting...';
        connectionStatus.style.display = 'block';
      }
      
      hideConnectionStatus() {
        connectionStatus.style.display = 'none';
      }
      
      handleSocketConnected(data) {
        console.log('Connected to server with socket ID:', data.socketId);
        
        // Update connection status
        updateConnectionIndicator('connected', 0);
        
        // Measure ping time periodically
        this.setupPingMeasurement();
      }
      
      /**
       * Set up periodic ping measurement
       */
      setupPingMeasurement() {
        // Clear existing interval
        if (this.pingInterval) {
          clearInterval(this.pingInterval);
        }
        
        // Ping every 15 seconds
        this.pingInterval = setInterval(() => {
          if (!this.socketManager.isConnected()) {
            updateConnectionIndicator('disconnected');
            return;
          }
          
          const startTime = Date.now();
          this.socketManager.emit('ping', { timestamp: startTime });
          
          // Set up one-time event handler for pong
          const pongHandler = (data) => {
            const endTime = Date.now();
            const pingTime = endTime - data.timestamp;
            
            // Update connection indicator
            updateConnectionIndicator('connected', pingTime);
            
            // Remove this one-time handler
            this.socketManager.off('pong', pongHandler);
          };
          
          this.socketManager.on('pong', pongHandler);
          
          // Timeout if no response
          setTimeout(() => {
            this.socketManager.off('pong', pongHandler);
            // If we didn't get a response, mark as poor connection
            updateConnectionIndicator('connected', 500);
          }, 2000);
        }, 15000);
      }
      
      handleSocketDisconnected() {
        console.log('Disconnected from server');
        
        // Update UI to show disconnected state
        updateConnectionIndicator('disconnected');
        
        // Show error message based on context
        if (this.mobileGameManager) {
          // If in game, show notification
          showNotification('Disconnected from server. Attempting to reconnect...', 'warning');
          this.attemptReconnect();
        } else {
          // If in lobby, show error
          this.showLobbyError('Disconnected from server. Please wait or refresh the page.');
          this.attemptReconnect();
        }
      }
      
      /**
       * Attempt to reconnect to the server
       */
      attemptReconnect() {
        // Update UI to show reconnecting state
        updateConnectionIndicator('reconnecting');
        
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        
        // Store room info for potential rejoin
        this.lastRoomCode = roomCodeInput.value.trim();
        this.lastUsername = usernameInput.value.trim();
        
        const attemptReconnection = () => {
          if (this.socketManager.isConnected()) {
            // We're connected again, reset state
            updateConnectionIndicator('connected', 100);
            showNotification('Reconnected to server.', 'info');
            
            // If we were in a game, rejoin the room
            if (this.lastRoomCode && this.lastUsername) {
              this.showConnectionStatus('Rejoining room...');
              this.gameStateManager.joinRoom(this.lastRoomCode, this.lastUsername);
            }
            return;
          }
          
          reconnectAttempts++;
          
          if (reconnectAttempts >= maxReconnectAttempts) {
            // Give up after several attempts
            updateConnectionIndicator('disconnected');
            this.showLobbyError('Failed to reconnect. Please refresh the page.');
            return;
          }
          
          // Try again in a few seconds
          setTimeout(attemptReconnection, 3000);
        };
        
        // Start the reconnection process after a short delay
        setTimeout(attemptReconnection, 2000);
      }
      
      handlePlayerJoined(data) {
        const player = data.player;
        console.log('Player joined:', player.username);
        
        // Show a notification
        showNotification(`${player.username} joined the room`, 'join');
        
        // Add player to the player list if we're in-game
        if (this.mobileGameManager) {
          // Find existing player with the same ID
          const existingPlayer = document.querySelector(`.player-item[data-player-id="${player.id}"]`);
          if (!existingPlayer) {
            // If not found, add to the list
            addPlayerToList(player);
            
            // Update player count
            const currentCount = parseInt(playerCount.textContent) || 0;
            playerCount.textContent = currentCount + 1;
          }
        }
      }
      
      handlePlayerLeft(data) {
        console.log('Player left:', data.playerId);
        
        // Get player name before removing from list
        const playerElement = document.querySelector(`.player-item[data-player-id="${data.playerId}"]`);
        let playerName = 'A player';
        
        if (playerElement) {
          const nameElement = playerElement.querySelector('.player-name');
          if (nameElement) {
            playerName = nameElement.textContent;
          }
          
          // Remove from list
          playerElement.remove();
          
          // Update player count
          const currentCount = parseInt(playerCount.textContent) || 0;
          if (currentCount > 0) {
            playerCount.textContent = currentCount - 1;
          }
        }
        
        // Show notification
        showNotification(`${playerName} left the room`, 'leave');
      }
      
      // Enable device sensors with permission handling
      async enableSensors() {
        // Request permission on iOS
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission !== 'granted') {
              console.log('Permission denied for orientation sensors');
              throw new Error('Sensor access denied');
            }
            return true;
          } catch (err) {
            console.error('Error requesting orientation permission:', err);
            throw err;
          }
        }
        
        // For non-iOS devices or if permission API is not available
        return new Promise((resolve, reject) => {
          // Add a one-time event listener to check if we receive sensor data
          const checkTimeout = setTimeout(() => {
            window.removeEventListener('deviceorientation', sensorCheckHandler);
            if (!sensorData.active) {
              reject(new Error('No sensor data received'));
            } else {
              resolve(true);
            }
          }, 2000);
          
          const sensorCheckHandler = (event) => {
            if (event.alpha !== null || event.beta !== null || event.gamma !== null) {
              clearTimeout(checkTimeout);
              window.removeEventListener('deviceorientation', sensorCheckHandler);
              resolve(true);
            }
          };
          
          window.addEventListener('deviceorientation', sensorCheckHandler, { once: false });
        });
      }
      
      // Show a message in the game view
      showGameMessage(message, duration = 5000) {
        const messageElement = document.getElementById('game-message');
        if (messageElement) {
          messageElement.textContent = message;
          messageElement.style.display = 'block';
          
          // Hide after specified duration
          if (duration > 0) {
            setTimeout(() => {
              messageElement.style.display = 'none';
            }, duration);
          }
        }
      }
    }
    
    // Initialize the application when the DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize the mobile lobby manager
      window.lobbyManager = new MobileLobbyManager();
    });
  </script>
</body>
</html>